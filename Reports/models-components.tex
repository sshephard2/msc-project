%
% ---- PEPA Component Models
%

\section{PEPA Component Models}\label{sec:pepa-component-models}

The first stage is to create suitable PEPA models for the selected technology components from section \ref{sec:technologies}, simple enough to be composed into more complex system models but still able to demonstrate interesting behaviour.  These models are tested using the PEPA Eclipse plugin \cite{RN1080} to calculate the steady-state throughputs of each activity for a given range of input rates for the activity with skewed demand.  The results are analysed to verify that the component models behave as expected for the technologies, and to discover any additional insights.  Note that there is no microservices component model.  Microservices is an architecture and will be shown in the System Modelling section.

%
% ---- Shared middleware queue
%
\FloatBarrier
\subsection{Shared middleware queue}

Work has already been done on modelling queueing systems in PEPA \cite{RN75}.  A single queue with a limited buffer size of $\mathit{N}$ may be written as (service and arrival components not shown, for brevity):

\begin{center}
\begin{displaymath}
\begin{array}{rcl}
\mathit{Queue_0} & \rmdef & (\mathit{arrival},\mathit{\top}).\mathit{Queue_1}\\
\mathit{Queue_j} & \rmdef & (\mathit{arrival},\mathit{\top}).\mathit{Queue_{j+1}} + (\mathit{service},\mathit{\top}).\mathit{Queue_{j-1}}, \mathit{1 \le j \le N-1}\\
\mathit{Queue_N} & \rmdef & (\mathit{service},\mathit{\top}).\mathit{Queue_{N-1}}\\
\end{array}
\end{displaymath}
\end{center}

Using aggregation, this may be more simply represented in an easily extensible form as $\mathit{Queue[N]}$.  The limitation of this representation however is that it makes no distinction between the states of individual queue position instances, only the numbers of instances in each state.  This means there is no ordering guarantee e.g. the First In First Out (FIFO).  Actual cloud service queues do not necessarily implement FIFO, for example Azure Storage Queues \cite{RN1072} do not guarantee it.

For the skewed demand use case, a queue must be able to support arrival actions at different rates, and must potentially be able to support service actions in different ways too.  Again \cite{RN75} suggests an approach for this model, with a queue synchronised with a linear combination of components with different characteristics.  Thus the PEPA model for a general shared queue is shown in Figure \ref{figure:pepa_queue_model}.

There are two arrival processes, one dealing with the arrival of cycling requests at a uniform, normal rate (here set to $\mathit{c=1.0}$) and one dealing with the athletics requests at skewed rates (starting at the same rate as cycling requests, and increasing in steps of 1.0 to 10.0).  The queue itself is an aggregation of $\mathit{N}$ components each of which has three states; an empty instance $\mathit{Q_0}$, `filled' with an athletics request $\mathit{Q_A}$, or filled with a cycling request $\mathit{Q_C}$.  Finally there are also two service processes, generalised here to $\mathit{Service_1}$ and $\mathit{Service_2}$ (in some of the system models, they will not necessarily be dedicated to serving athletics or cycling requests), both with the same maximum service rate of $\mathit{s=5}$.  The higher rates of skewed demand are therefore more than the service processes can handle.

\begin{figure}
	\caption{Shared queue PEPA model}
	\label{figure:pepa_queue_model}
	\centering
	% Automatically generated by PEPA2Latex
	% --begin
	\begin{displaymath}
		\begin{array}{rcl}
			\mathit{a} & = & 1.0-10.0\\
			\mathit{c} & = & 1.0\\
			\mathit{s1} & = & 5.0\\
			\mathit{s2} & = & 5.0\\
			[2.0ex]		\mathit{Arrival_A} & \rmdef & (\mathit{athletics},\mathit{a}).\mathit{Arrival_A}\\
			\mathit{Arrival_C} & \rmdef & (\mathit{cycling},\mathit{c}).\mathit{Arrival_C}\\
			\mathit{Service_1} & \rmdef & (\mathit{serve1},\mathit{s1}).\mathit{Service_1}\\
			\mathit{Service_2} & \rmdef & (\mathit{serve2},\mathit{s2}).\mathit{Service_2}\\
			[2.0ex]		\mathit{Q_0} & \rmdef & (\mathit{athletics},\top).\mathit{Q_A}+(\mathit{cycling},\top).\mathit{Q_C}\\
			\mathit{Q_A} & \rmdef & (\mathit{serve1},\top).\mathit{Q_0}\\
			\mathit{Q_C} & \rmdef & (\mathit{serve2},\top).\mathit{Q_0}\\
			[2.0ex]		\multicolumn{3}{l}{\mathit{Arrival_A}\sync{athletics}\mathit{Q_0}[N]\sync{serve1}\mathit{Service_1}\sync{cycling}\mathit{Arrival_C}\sync{serve2}\mathit{Service_2}}\\
			[2.0ex]	\end{array}
	\end{displaymath}
	% --end
\end{figure}

\FloatBarrier
The model is tested in the Eclipse plugin using a series of different queue lengths $\mathit{N}$ and for different rates of athletics demand $\mathit{a}$ from 1 to 10.  This provides the actual throughputs in steady state of each activity.  Figure \ref{figure:queue_athletics} shows the throughput of {\itshape athletics} for exponentially increasing queue lengths from 1 to 20.  Figure \ref{figure:queue_cycling} shows the same for {\itshape cycling}.  Table \ref{table:queue_results} shows the numerical results for a queue of length N=10.
The results demonstrate that:
\begin{itemize}
	\item the throughput of {\itshape athletics} is constrained by the maximum service rate of the process handling those requests.
	\item the throughput of {\itshape cycling} is constrained by the ratio between the input rates of athletics and cycling.  When the input rate of athletics requests is 10 times that of cycling requests, then the queue holds these requests in a 10:1 ratio.  As the actual {\itshape athletics} throughput may not exceed the service rate $\mathit{s=5}$, then the cycling throughput is throttled to 0.5.
	\item for larger queue sizes, the throughputs approach their maximum limits.  A real queue service has an effectively unlimited length, but in PEPA models the state space quickly becomes too large for the Eclipse plugin to handle.  It is a useful result, therefore, to find that for a maximum skewed demand of 10 times the normal demand, a queue length of 10 gives a practical and well performing model.
\end{itemize}

\begin{figure}
	\caption{Shared queue experimental results - athletics}
	\label{figure:queue_athletics}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	title={Throughput of athletics against input rate a for different queue lengths N},
	xlabel={Rate a},
	ylabel={Throughput athletics},
	xmin=0, xmax=10,
	ymin=0, ymax=5,
	legend pos=north west,
	ymajorgrids=true,
	grid style=dashed,
	cycle multiindex* list={
		mark list*
		\nextlist
		cyan,brown,green,blue,red
	}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N1_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N2_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N5_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N10_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N20_arrive_1.csv};
	
	\legend{N = 1, N = 2, N = 5, N = 10, N = 20}
	
	\end{axis}
	\end{tikzpicture}
\end{figure}
\begin{figure}
	\caption{Shared queue experimental results - cycling}
	\label{figure:queue_cycling}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	title={Throughput of cycling against input rate a for different queue lengths N},
	xlabel={Rate a},
	ylabel={Throughput cycling},
	xmin=0, xmax=10,
	ymin=0, ymax=1,
	legend pos=south west,
	ymajorgrids=true,
	grid style=dashed,
	cycle multiindex* list={
		mark list*
		\nextlist
		cyan,brown,green,blue,red
	}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N1_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N2_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N5_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N10_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N20_arrive_2.csv};
	
	\legend{N = 1, N = 2, N = 5, N = 10, N = 20}
	
	\end{axis}
	\end{tikzpicture}
\end{figure}

\begin{table}[h!]
	\begin{center}
		\caption{Shared queue N=10 experimental results}
		\label{table:queue_results}
		\pgfplotstabletypeset[
		col sep=comma,
		string type,
		columns/a/.style={column name=a, column type={p{.1\textwidth}}},
		columns/athletics/.style={column name=athletics, column type={p{.1\textwidth}}},
		columns/cycling/.style={column name=cycling, column type={p{.1\textwidth}}},
		columns/ratio/.style={column name=ratio, column type={p{.1\textwidth}}},
		columns/serve1/.style={column name=serve1, column type={p{.1\textwidth}}},
		columns/serve2/.style={column name=serve2, column type={p{.1\textwidth}}},
		every head row/.style={before row=\hline Rate & \multicolumn{5}{c}{Throughput} \\,after row=\hline},
		every last row/.style={after row=\hline},
		]{data/queue/N10_results.csv}
	\end{center}
\end{table}

%
% ---- Database models
%
\FloatBarrier
\subsection{Database models}
A very simple representation of a single database process is a component that receives a request for data (either read or write) at some rate based on demand, and serves it at a rate based on the database's performance:
\begin{center}
$\mathit{DB} \rmdef (\mathit{request}, r).(\mathit{dbsrv}, db).\mathit{DB}$
\end{center}
This is a highly abstract representation.  It does not model features such as session management, parallelism, caching, locking or any notion that data manipulation statements vary in complexity and expense.  Nevertheless it is a useful building block for distributed databases, as shown below.

%
% ---- Distributed database without replication
%
\FloatBarrier
\subsubsection{Distributed database.} Figure \ref{figure:pepa_ddnr_model} shows a model of a distributed database, where the data has been partitioned by sport onto two different database nodes with identical performance.  The data request activities are {\itshape athletics} and {\itshape cycling}.  These may represent search, book or return operations on athletics or cycling tickets.  Users may search for either type of ticket from the website component, and the code or database engine will route the search to the correct data node.  Thus $\mathit{DB_1}$ here is able to service {\itshape athletics} requests, at a maximum rate of {\itshape db}, and $\mathit{DB_2}$ can service {\itshape cycling} requests at the same rate (the model assumes homogeneous database nodes to reduce the variables under consideration, although as there are separate database service processes it is extensible to heterogeneous systems).  Both nodes execute in parallel without cooperating on any activities.

\begin{figure}
	\caption{Distributed database PEPA model}
	\label{figure:pepa_ddnr_model}
	\centering
	% Automatically generated by PEPA2Latex
	% --begin
	\begin{displaymath}
	\begin{array}{rcl}
	\mathit{a} & = & 1.0-10.0\\
	\mathit{c} & = & 1.0\\
	\mathit{db} & = & 5.0\\
	[2.0ex]		\mathit{Website} & \rmdef & (\mathit{athletics},\mathit{a}).\mathit{Website}+(\mathit{cycling},\mathit{c}).\mathit{Website}\\
	\mathit{DB_1} & \rmdef & (\mathit{athletics},\top).\mathit{DBsrv_1}\\
	\mathit{DBsrv_1} & \rmdef & (\mathit{dbsrv1},\top).\mathit{DB_1}\\
	\mathit{DB_2} & \rmdef & (\mathit{cycling},\top).\mathit{DBsrv_2}\\
	\mathit{DBsrv_2} & \rmdef & (\mathit{dbsrv2},\top).\mathit{DB_2}\\
	\mathit{Service_1} & \rmdef & (\mathit{dbsrv1},\mathit{db}).\mathit{Service_1}\\
	\mathit{Service_2} & \rmdef & (\mathit{dbsrv2},\mathit{db}).\mathit{Service_2}\\
	[2.0ex]		\multicolumn{3}{l}{\mathit{Website}\sync{\substack{athletics\\cycling}}\mathit{DB_1}\parallel\mathit{DB_2}\sync{\substack{dbsrv1\\dbsrv2}}\mathit{Service_1}\parallel\mathit{Service_2}}\\
	[2.0ex]	\end{array}
	\end{displaymath}
	% --end
\end{figure}

\FloatBarrier
Experiments are carried out in the Eclipse plugin by fixing the input rate of {\itshape db} at 5.0, the rate {\itshape c} of cycling requests to 1.0 and by testing each input rate {\itshape a} of athletics requests from 1.0 to 10.0 in steps of 1.0, to simulate increasing levels of skewed demand for athletics tickets which becomes too high for a single database node to service.  Table \ref{table:ddnr_results} shows the numerical results, Figure \ref{figure:ddnr_sport} shows the throughput of both {\itshape athletics} and {\itshape cycling} against the skewed input rate {\itshape a}, and Figure \ref{figure:ddnr_database} shows the throughput of each database node against the same range of inputs.
The results show that:
\begin{itemize}
	\item the throughput of {\itshape athletics} is constrained by the maximum service rate of the database node handling those requests, and both athletics and cycling activities demonstrate loss of throughput.
	\item the throughput of {\itshape cycling} is independent of athletics.
	\item the database node throughput follows the throughput of each sport activity, i.e. the partitioning strategy routes all the demand onto the node handling that sport.
\end{itemize}

\begin{table}[h!]
	\begin{center}
		\caption{Distributed database without replication experimental results}
		\label{table:ddnr_results}
			\pgfplotstabletypeset[
			col sep=comma,
			string type,
			columns/a/.style={column name=a, column type={p{.1\textwidth}}},
			columns/athletics/.style={column name=athletics, column type={p{.1\textwidth}}},
			columns/cycling/.style={column name=cycling, column type={p{.1\textwidth}}},
			columns/dbsrv1/.style={column name=dbsrv1, column type={p{.1\textwidth}}},
			columns/dbsrv2/.style={column name=dbsrv2, column type={p{.1\textwidth}}},
			every head row/.style={before row=\hline Rate & \multicolumn{4}{c}{Throughput} \\,after row=\hline},
			every last row/.style={after row=\hline},
			]{data/ddnr/results.csv}
	\end{center}
\end{table}

\begin{figure}
	\caption{Distributed database without replication - sport throughput}
	\label{figure:ddnr_sport}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
		title={Throughput against input rate a},
		xlabel={Rate a},
		ylabel={Throughput},
		xmin=0, xmax=10,
		ymin=0, ymax=5,
		legend pos=north west,
		ymajorgrids=true,
		grid style=dashed,
		cycle multiindex* list={
			mark list*
				\nextlist
			cyan,brown,green,blue,red
		}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddnr/book_a.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddnr/book_c.csv};

	\legend{athletics,cycling}

	\end{axis}
	\end{tikzpicture}
\end{figure}
\begin{figure}
	\caption{Distributed database without replication - database throughput}
	\label{figure:ddnr_database}
	\centering
	\begin{tikzpicture}
\begin{axis}[
title={Throughput against input rate a},
width=0.9\textwidth,
ybar=0pt,
bar width=.02\textwidth,
xlabel={Rate a},
ylabel={Throughput},
xtick=data,
ymin=0, ymax=5,
legend pos=north west,
ymajorgrids=true,
grid style=dashed,
]

\addplot [pattern=north east lines, pattern color=blue] table [x index={0}, y index={1}, col sep=comma]{data/ddnr/dbsrv_1.csv};
\addplot [fill=green] table [x index={0}, y index={1}, col sep=comma]{data/ddnr/dbsrv_2.csv};

\legend{dbsrv1,dbsrv2}

\end{axis}
\end{tikzpicture}
\end{figure}

%
% ---- Distributed database with replication
%
\FloatBarrier
\subsubsection{Distributed database with replication.}  Constructing and meaningfully testing a model of a distributed database using consistent hashing with replication requires at least three types of sport tickets, so a {\itshape diving} activity is introduced.  The partitioning strategy is as the previous model, but now $\mathit{DB_1}$ is able to service {\itshape athletics} and {\itshape cycling} requests,  $\mathit{DB_2}$ handles {\itshape cycling} and {\itshape diving}, and $\mathit{DB_3}$ handles {\itshape athletics} and {\itshape diving} as shown in Figure \ref{figure:pepa_ddwr_model}.  This model makes a key assumption that each data node handles each supported sport with equal probability, and once again each node operates at an identical rate that is insufficient to meet the skewed demand.

\begin{figure}
	\caption{Distributed database with replication PEPA model}
	\label{figure:pepa_ddwr_model}
	\centering
	% Automatically generated by PEPA2Latex
	% --begin
	\begin{displaymath}
	\begin{array}{rcl}
	\mathit{a} & = & 1.0-10.0\\
	\mathit{c} & = & 1.0\\
	\mathit{d} & = & 1.0\\
	\mathit{db} & = & 5.0\\
	[2.0ex]		\mathit{Website} & \rmdef & (\mathit{athletics},\mathit{a}).\mathit{Website}+(\mathit{cycling},\mathit{c}).\mathit{Website}+(\mathit{diving},\mathit{d}).\mathit{Website}\\
	\mathit{DB_1} & \rmdef & (\mathit{athletics},\top).\mathit{DBsrv_1}+(\mathit{cycling},\top).\mathit{DBsrv_1}\\
	\mathit{DBsrv_1} & \rmdef & (\mathit{dbsrv1},\top).\mathit{DB_1}\\
	\mathit{DB_2} & \rmdef & (\mathit{cycling},\top).\mathit{DBsrv_2}+(\mathit{diving},\top).\mathit{DBsrv_2}\\
	\mathit{DBsrv_2} & \rmdef & (\mathit{dbsrv2},\top).\mathit{DB_2}\\
	\mathit{DB_3} & \rmdef & (\mathit{diving},\top).\mathit{DBsrv_3}+(\mathit{athletics},\top).\mathit{DBsrv_3}\\
	\mathit{DBsrv_3} & \rmdef & (\mathit{dbsrv3},\top).\mathit{DB_3}\\
	\mathit{Service_1} & \rmdef & (\mathit{dbsrv1},\mathit{db}).\mathit{Service_1}\\
	\mathit{Service_2} & \rmdef & (\mathit{dbsrv2},\mathit{db}).\mathit{Service_2}\\
	\mathit{Service_3} & \rmdef & (\mathit{dbsrv3},\mathit{db}).\mathit{Service_3}\\
	[2.0ex]		\multicolumn{3}{l}{\mathit{Website}\sync{\substack{athletics\\cycling\\diving}}\mathit{DB_1}\parallel\mathit{DB_2}\parallel\mathit{DB_3}\sync{\substack{dbsrv1\\dbsrv2\\dbsrv3}}\mathit{Service_1}\parallel\mathit{Service_2}\parallel\mathit{Service_3}}\\
	[2.0ex]	\end{array}
	\end{displaymath}
	% --end
\end{figure}

Experiments are carried out in the Eclipse plugin by fixing the input rate of {\itshape db} at 5.0, the rates {\itshape c} and {\itshape d} of cycling and diving requests to 1.0 and by testing each input rate {\itshape a} of athletics requests from 1.0 to 10.0 in steps of 1.0.  The numerical results in Table \ref{table:ddwr_results} show that the throughputs of cycling and diving are identical.   Figure \ref{figure:ddwr_sport} therefore shows only the throughput of {\itshape athletics} and {\itshape cycling} against the skewed input rate {\itshape a} (the plots of cycling and diving would be superimposed).  Figure \ref{figure:ddwr_database} shows the throughput of all three database nodes against the same range of inputs.
The results show that:
\begin{itemize}
	\item the throughput of {\itshape athletics} is higher than for the distributed database without replication.  The extra demand has been shared between both data nodes supporting athletics requests.
	\item the throughput of {\itshape cycling} and {\itshape diving} are no longer independent of athletics.  They no longer reside only on data nodes that are independent of athletics demand.
	\item the database node throughput of the two nodes supporting athletics requests is equal, and both are higher than the remaining data node that supports only cycling and diving.  The throughput of this node increases as athletics throughput increases however, suggesting the node is picking up an increasing proportion of the constant demand for cycling and diving tickets.
\end{itemize}

\FloatBarrier
\begin{table}[h!]
	\begin{center}
		\caption{Distributed database with replication experimental results}
		\label{table:ddwr_results}
		\pgfplotstabletypeset[
		col sep=comma,
		string type,
		columns/a/.style={column name=a, column type={p{.1\textwidth}}},
		columns/athletics/.style={column name=athletics, column type={p{.1\textwidth}}},
		columns/cycling/.style={column name=cycling, column type={p{.1\textwidth}}},
		columns/diving/.style={column name=diving, column type={p{.1\textwidth}}},
		columns/dbsrv1/.style={column name=dbsrv1, column type={p{.1\textwidth}}},
		columns/dbsrv2/.style={column name=dbsrv2, column type={p{.1\textwidth}}},
		columns/dbsrv3/.style={column name=dbsrv3, column type={p{.1\textwidth}}},
		every head row/.style={before row=\hline Rate & \multicolumn{6}{c}{Throughput} \\,after row=\hline},
		every last row/.style={after row=\hline},
		]{data/ddwr/results.csv}
	\end{center}
\end{table}

\begin{figure}
	\caption{Distributed database with replication - sport throughput}
	\label{figure:ddwr_sport}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	title={Throughput against input rate a},
	xlabel={Rate a},
	ylabel={Throughput},
	xmin=0, xmax=10,
	ymin=0, ymax=6,
	legend pos=north west,
	ymajorgrids=true,
	grid style=dashed,
	cycle multiindex* list={
		mark list*
		\nextlist
		cyan,brown,green,blue,red
	}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddwr/book_a.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddwr/book_c.csv};
	
	\legend{athletics,cycling}
	
	\end{axis}
	\end{tikzpicture}
\end{figure}

\begin{figure}
	\caption{Distributed database with replication - database throughput}
	\label{figure:ddwr_database}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
		title={Throughput against input rate a},
		width=0.9\textwidth,
		ybar=0pt,
		bar width=.02\textwidth,
		xlabel={Rate a},
		ylabel={Throughput},
		xtick=data,
		ymin=0, ymax=5,
		legend pos=north west,
		ymajorgrids=true,
		grid style=dashed,
	]
	
	\addplot [pattern=north east lines, pattern color=blue] table [x index={0}, y index={1}, col sep=comma]{data/ddwr/dbsrv_1.csv};
	\addplot [fill=green] table [x index={0}, y index={1}, col sep=comma]{data/ddwr/dbsrv_2.csv};
	\addplot [pattern=crosshatch, pattern color=brown] table [x index={0}, y index={1}, col sep=comma]{data/ddwr/dbsrv_3.csv};

	\legend{dbsrv1,dbsrv2,dbsrv3}

	\end{axis}
	\end{tikzpicture}
\end{figure}