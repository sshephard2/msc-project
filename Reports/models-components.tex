%
% ---- PEPA Component Models
%

\section{PEPA Component Models}\label{sec:pepa-component-models}

The first stage is to create suitable PEPA models for the selected technology components from section \ref{sec:technologies}, simple enough to be composed into more complex system models but still able to demonstrate interesting behaviour.  These models are tested using the PEPA Eclipse plugin \cite{RN1080} to calculate the steady-state throughputs of each activity for a given range of input rates for the activity with skewed demand.  The results are analysed to verify that the component models behave as expected for the technologies, and to discover any additional insights.

%
% ---- Shared middleware queue
%
\FloatBarrier
\subsection{Shared middleware queue}

Work has already been done on modelling queueing systems in PEPA \cite{RN75}.  A single queue with a limited buffer size of $\mathit{N}$ may be written as (service and arrival components not shown, for brevity):

\begin{displaymath}
\begin{array}{rcl}
\mathit{Queue_0} & \rmdef & (\mathit{arrival},\mathit{\top}).\mathit{Queue_1}\\
\mathit{Queue_j} & \rmdef & (\mathit{arrival},\mathit{\top}).\mathit{Queue_{j+1}} + (\mathit{service},\mathit{\top}).\mathit{Queue_{j-1}}, \mathit{1 \le j \le N-1}\\
\mathit{Queue_N} & \rmdef & (\mathit{service},\mathit{\top}).\mathit{Queue_{N-1}}\\
\end{array}
\end{displaymath}

Using aggregration, this may be more simply represented in an easily extensible form as $\mathit{Queue[N]}$.  The limitation of this representation however is that it makes no distinction between the states of individual queue position instances, only the numbers of instances in each state.  Therefore there is no ordering guarantee e.g. the queue is not guaranteed to be First In First Out (FIFO).  Actual cloud service queues do not necessarily implement FIFO, for example Azure Storage Queues \cite{RN1072} do not guarantee it.

For the skewed demand use case, a queue must be able to support arrival actions at different rates, and must potentially be able to support service actions in different ways too.  Again \cite{RN75} suggests an approach for this model, with a queue synchronised with a linear combination of components with different characteristics.  Thus the PEPA model for a general shared queue is shown in Figure \ref{figure:pepa_queue_model}.

There are two arrival processes, one dealing with the arrival of cycling requests at a uniform, normal rate (here set to $\mathit{c=1}$) and one dealing with the athletics requests at skewed rates (starting at the same rate as cycling requests, and increasing to 10 times that rate).  The queue itself is an aggregation of $\mathit{N}$ components each of which has three states; an empty instance $\mathit{Q_0}$, `filled' with an athletics request $\mathit{Q_A}$, or filled with a cycling request $\mathit{Q_C}$.  Finally there are also two service processes, generalised here to $\mathit{Service_1}$ and $\mathit{Service_2}$ (in some of the system models, they will not necessarily be dedicated to serving athletics or cycling requests), both with the same maximum service rate of $\mathit{s=5}$.  The higher rates of skewed demand are therefore more than the service processes can handle.

\begin{figure}
	\caption{Shared queue PEPA model}
	\label{figure:pepa_queue_model}
	\centering
	% Automatically generated by PEPA2Latex
	% --begin
	\begin{displaymath}
		\begin{array}{rcl}
			\mathit{a} & = & 1.0-10.0\\
			\mathit{c} & = & 1.0\\
			\mathit{s1} & = & 5.0\\
			\mathit{s2} & = & 5.0\\
			[2.0ex]		\mathit{Arrival_A} & \rmdef & (\mathit{athletics},\mathit{a}).\mathit{Arrival_A}\\
			\mathit{Arrival_C} & \rmdef & (\mathit{cycling},\mathit{c}).\mathit{Arrival_C}\\
			\mathit{Service_1} & \rmdef & (\mathit{serve1},\mathit{s1}).\mathit{Service_1}\\
			\mathit{Service_2} & \rmdef & (\mathit{serve2},\mathit{s2}).\mathit{Service_2}\\
			[2.0ex]		\mathit{Q_0} & \rmdef & (\mathit{athletics},\top).\mathit{Q_A}+(\mathit{cycling},\top).\mathit{Q_C}\\
			\mathit{Q_A} & \rmdef & (\mathit{serve1},\top).\mathit{Q_0}\\
			\mathit{Q_C} & \rmdef & (\mathit{serve2},\top).\mathit{Q_0}\\
			[2.0ex]		\multicolumn{3}{l}{\mathit{Arrival_A}\sync{athletics}\mathit{Q_0}[N]\sync{serve1}\mathit{Service_1}\sync{cycling}\mathit{Arrival_C}\sync{serve2}\mathit{Service_2}}\\
			[2.0ex]	\end{array}
	\end{displaymath}
	% --end
\end{figure}

\FloatBarrier
The model was tested in the Eclipse plugin using a series of different queue lengths $\mathit{N}$ and for different rates of athletics demand $\mathit{a}$ from 1 to 10.  This provided the actual throughputs in steady state of each activity.  Figure \ref{figure:queue_athletics} shows the throughput of {\itshape athletics} for exponentially increasing queue lengths from 1 to 20.  Figure \ref{figure:queue_cycling} shows the same for {\itshape cycling}.  Table \ref{table:queue_results} shows the numerical results for a queue of length N=10.
The results demonstrate that:
\begin{itemize}
	\item the throughput of {\itshape athletics} is constrained by the maximum service rate of the process handling those requests.
	\item the throughput of {\itshape cycling} is constrained by the ratio between the input rates of athletics and cycling.  When the input rate of athletics requests is 10 times that of cycling requests, then the queue holds these requests in a 10:1 ratio.  As the actual {\itshape athletics} throughput may not exceed the service rate $\mathit{s=5}$, then the cycling throughput is throttled to 0.5.
	\item for larger queue sizes, the arrival and service processes are less coupled, and the throughputs approach their maximum limits.  A real queue service has an effectively unlimited length, but in PEPA models the state space quickly becomes too large for the Eclipse plugin to handle.  It is a useful result, therefore, to find that for a maximum skewed demand of 10 times the normal demand, a queue length of 10 gives a practical model with sufficient decoupling.
\end{itemize}

\begin{figure}
	\caption{Shared queue experimental results - athletics}
	\label{figure:queue_athletics}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	title={Throughput of athletics against input rate a for different queue lengths N},
	xlabel={Rate a},
	ylabel={Throughput athletics},
	xmin=0, xmax=10,
	ymin=0, ymax=5,
	legend pos=north west,
	ymajorgrids=true,
	grid style=dashed,
	cycle multiindex* list={
		mark list*
		\nextlist
		cyan,brown,green,blue,red
	}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N1_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N2_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N5_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N10_arrive_1.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N20_arrive_1.csv};
	
	\legend{N = 1, N = 2, N = 5, N = 10, N = 20}
	
	\end{axis}
	\end{tikzpicture}
\end{figure}
\begin{figure}
	\caption{Shared queue experimental results - cycling}
	\label{figure:queue_cycling}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	title={Throughput of cycling against input rate a for different queue lengths N},
	xlabel={Rate a},
	ylabel={Throughput cycling},
	xmin=0, xmax=10,
	ymin=0, ymax=1,
	legend pos=south west,
	ymajorgrids=true,
	grid style=dashed,
	cycle multiindex* list={
		mark list*
		\nextlist
		cyan,brown,green,blue,red
	}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N1_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N2_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N5_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N10_arrive_2.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/queue/N20_arrive_2.csv};
	
	\legend{N = 1, N = 2, N = 5, N = 10, N = 20}
	
	\end{axis}
	\end{tikzpicture}
\end{figure}

\begin{table}[h!]
	\begin{center}
		\caption{Shared queue N=10 experimental results}
		\label{table:queue_results}
		\pgfplotstabletypeset[
		col sep=comma,
		string type,
		columns/a/.style={column name=a, column type={p{.1\textwidth}}},
		columns/athletics/.style={column name=athletics, column type={p{.1\textwidth}}},
		columns/cycling/.style={column name=cycling, column type={p{.1\textwidth}}},
		columns/ratio/.style={column name=ratio, column type={p{.1\textwidth}}},
		columns/serve1/.style={column name=serve1, column type={p{.1\textwidth}}},
		columns/serve2/.style={column name=serve2, column type={p{.1\textwidth}}},
		every head row/.style={before row=\hline Rate & \multicolumn{5}{c}{Throughput} \\,after row=\hline},
		every last row/.style={after row=\hline},
		]{data/queue/N10_results.csv}
	\end{center}
\end{table}

%
% ---- Database models
%
\FloatBarrier
\subsection{Database models}
\begin{shaded}
A very simple representation of a single database process is a component that receives a request for data (either read or write) at some rate based on demand, and serves it at a rate based on the database's performance, e.g.
\begin{center}
$\mathit{DB} \rmdef (\mathit{request}, r).(\mathit{dbsrv}, db).\mathit{DB}$
\end{center}
What doesn't this model?  Statement about how the models below show that it can still be a useful building block.
\end{shaded}

%
% ---- Distributed database without replication
%
\FloatBarrier
\begin{shaded}
\subsubsection{Distributed database.} Figure \ref{figure:pepa_ddnr_model} shows a model of a distributed database, where the data has been partitioned by sport onto two different database nodes with identical performance.  The data request activities are {\itshape athletics} and {\itshape cycling}.  These may represent search, book or return operations on athletics or cycling tickets.  Users may search for either type of ticket from the website component, and the code or database engine will route the search to the correct data node.  Thus $\mathit{DB_1}$ here is able to service {\itshape athletics} requests, at a maximum rate of {\itshape db}, and $\mathit{DB_2}$ can service {\itshape cycling} requests at the same rate.  Both nodes execute in parallel without cooperating on any activities.
Experiments are carried out in PEPA workbench by fixing the input rate of {\itshape db} at 5.0, the rate {\itshape c} of cycling requests to 1.0 and by testing each input rate {\itshape a} of athletics requests from 1.0 to 10.0 in steps of 1.0, to simulate increasing levels of skewed demand for athletics tickets which becomes too high for a database node to service.  The results appear in Table \ref{table:ddnr_results}.
\end{shaded}

\begin{figure}
	\caption{Distributed database PEPA model}
	\label{figure:pepa_ddnr_model}
	\centering
	% Automatically generated by PEPA2Latex
	% --begin
	\begin{displaymath}
	\begin{array}{rcl}
	\mathit{a} & = & 1.0-10.0\\
	\mathit{c} & = & 1.0\\
	\mathit{db} & = & 5.0\\
	[2.0ex]		\mathit{Website} & \rmdef & (\mathit{athletics},\mathit{a}).\mathit{Website}+(\mathit{cycling},\mathit{c}).\mathit{Website}\\
	\mathit{DB_1} & \rmdef & (\mathit{athletics},\top).\mathit{DBsrv_1}\\
	\mathit{DBsrv_1} & \rmdef & (\mathit{dbsrv1},\top).\mathit{DB_1}\\
	\mathit{DB_2} & \rmdef & (\mathit{cycling},\top).\mathit{DBsrv_2}\\
	\mathit{DBsrv_2} & \rmdef & (\mathit{dbsrv2},\top).\mathit{DB_2}\\
	\mathit{Service_1} & \rmdef & (\mathit{dbsrv1},\mathit{db}).\mathit{Service_1}\\
	\mathit{Service_2} & \rmdef & (\mathit{dbsrv2},\mathit{db}).\mathit{Service_2}\\
	[2.0ex]		\multicolumn{3}{l}{\mathit{Website}\sync{\substack{athletics\\cycling}}\mathit{DB_1}\parallel\mathit{DB_2}\sync{\substack{dbsrv1\\dbsrv2}}\mathit{Service_1}\parallel\mathit{Service_2}}\\
	[2.0ex]	\end{array}
	\end{displaymath}
	% --end
\end{figure}

\begin{table}[h!]
	\begin{center}
		\caption{Distributed database experimental results}
		\label{table:ddnr_results}
			\pgfplotstabletypeset[
			col sep=comma,
			string type,
			columns/a/.style={column name=a, column type={p{.1\textwidth}}},
			columns/athletics/.style={column name=athletics, column type={p{.1\textwidth}}},
			columns/cycling/.style={column name=cycling, column type={p{.1\textwidth}}},
			columns/dbsrv1/.style={column name=dbsrv1, column type={p{.1\textwidth}}},
			columns/dbsrv2/.style={column name=dbsrv2, column type={p{.1\textwidth}}},
			every head row/.style={before row=\hline Rate & \multicolumn{4}{c}{Throughput} \\,after row=\hline},
			every last row/.style={after row=\hline},
			]{data/ddnr/results.csv}
	\end{center}
\end{table}

\begin{figure}
	\caption{Distributed database without replication - sport throughput}
	\label{figure:ddnr_sport}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
		title={Throughput against input rate a},
		xlabel={Rate a},
		ylabel={Throughput},
		xmin=0, xmax=10,
		ymin=0, ymax=5,
		legend pos=north west,
		ymajorgrids=true,
		grid style=dashed,
		cycle multiindex* list={
			mark list*
				\nextlist
			cyan,brown,green,blue,red
		}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddnr/book_a.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddnr/book_c.csv};

	\legend{athletics,cycling}

	\end{axis}
	\end{tikzpicture}
\end{figure}
\begin{figure}
	\caption{Distributed database without replication - database throughput}
	\label{figure:ddnr_database}
	\centering
	\begin{tikzpicture}
\begin{axis}[
title={Throughput against input rate a},
width=0.9\textwidth,
ybar=0pt,
bar width=.02\textwidth,
xlabel={Rate a},
ylabel={Throughput},
xtick=data,
ymin=0, ymax=5,
legend pos=north west,
ymajorgrids=true,
grid style=dashed,
]

\addplot [pattern=north east lines, pattern color=blue] table [x index={0}, y index={1}, col sep=comma]{data/ddnr/dbsrv_1.csv};
\addplot [fill=green] table [x index={0}, y index={1}, col sep=comma]{data/ddnr/dbsrv_2.csv};

\legend{dbsrv1,dbsrv2}

\end{axis}
\end{tikzpicture}
\end{figure}

%
% ---- Distributed database with replication
%
\FloatBarrier
\begin{shaded}
\subsubsection{Distributed database with replication.} The PEPA model for a distributed database is shown in Figure \ref{figure:pepa_ddwr_model}.
\end{shaded}

\begin{figure}
	\caption{Distributed database with replication PEPA model}
	\label{figure:pepa_ddwr_model}
	\centering
	% Automatically generated by PEPA2Latex
	% --begin
	\begin{displaymath}
	\begin{array}{rcl}
	\mathit{a} & = & 1.0\\
	\mathit{c} & = & 1.0\\
	\mathit{d} & = & 1.0\\
	\mathit{db} & = & 5.0\\
	[2.0ex]		\mathit{Website} & \rmdef & (\mathit{athletics},\mathit{a}).\mathit{Website}+(\mathit{cycling},\mathit{c}).\mathit{Website}+(\mathit{diving},\mathit{d}).\mathit{Website}\\
	\mathit{DB_1} & \rmdef & (\mathit{athletics},\top).\mathit{DBsrv_1}+(\mathit{cycling},\top).\mathit{DBsrv_1}\\
	\mathit{DBsrv_1} & \rmdef & (\mathit{dbsrv1},\top).\mathit{DB_1}\\
	\mathit{DB_2} & \rmdef & (\mathit{cycling},\top).\mathit{DBsrv_2}+(\mathit{diving},\top).\mathit{DBsrv_2}\\
	\mathit{DBsrv_2} & \rmdef & (\mathit{dbsrv2},\top).\mathit{DB_2}\\
	\mathit{DB_3} & \rmdef & (\mathit{diving},\top).\mathit{DBsrv_3}+(\mathit{athletics},\top).\mathit{DBsrv_3}\\
	\mathit{DBsrv_3} & \rmdef & (\mathit{dbsrv3},\top).\mathit{DB_3}\\
	\mathit{Service_1} & \rmdef & (\mathit{dbsrv1},\mathit{db}).\mathit{Service_1}\\
	\mathit{Service_2} & \rmdef & (\mathit{dbsrv2},\mathit{db}).\mathit{Service_2}\\
	\mathit{Service_3} & \rmdef & (\mathit{dbsrv3},\mathit{db}).\mathit{Service_3}\\
	[2.0ex]		\multicolumn{3}{l}{\mathit{Website}\sync{\substack{athletics\\cycling\\diving}}\mathit{DB_1}\parallel\mathit{DB_2}\parallel\mathit{DB_3}\sync{\substack{dbsrv1\\dbsrv2\\dbsrv3}}\mathit{Service_1}\parallel\mathit{Service_2}\parallel\mathit{Service_3}}\\
	[2.0ex]	\end{array}
	\end{displaymath}
	% --end
\end{figure}

See the experimental results in Table \ref{table:ddwr_results}.

\begin{table}[h!]
	\begin{center}
		\caption{Distributed database with replication experimental results}
		\label{table:ddwr_results}
		\pgfplotstabletypeset[
		col sep=comma,
		string type,
		columns/a/.style={column name=a, column type={p{.1\textwidth}}},
		columns/athletics/.style={column name=athletics, column type={p{.1\textwidth}}},
		columns/cycling/.style={column name=cycling, column type={p{.1\textwidth}}},
		columns/diving/.style={column name=diving, column type={p{.1\textwidth}}},
		columns/dbsrv1/.style={column name=dbsrv1, column type={p{.1\textwidth}}},
		columns/dbsrv2/.style={column name=dbsrv2, column type={p{.1\textwidth}}},
		columns/dbsrv3/.style={column name=dbsrv3, column type={p{.1\textwidth}}},
		every head row/.style={before row=\hline Rate & \multicolumn{6}{c}{Throughput} \\,after row=\hline},
		every last row/.style={after row=\hline},
		]{data/ddwr/results.csv}
	\end{center}
\end{table}

\begin{figure}
	\caption{Distributed database with replication - sport throughput}
	\label{figure:ddwr_sport}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	title={Throughput against input rate a},
	xlabel={Rate a},
	ylabel={Throughput},
	xmin=0, xmax=10,
	ymin=0, ymax=6,
	legend pos=north west,
	ymajorgrids=true,
	grid style=dashed,
	cycle multiindex* list={
		mark list*
		\nextlist
		cyan,brown,green,blue,red
	}
	]
	
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddwr/book_a.csv};
	\addplot table [x index={0}, y index={1}, col sep=comma]{data/ddwr/book_c.csv};
	
	\legend{athletics,cycling}
	
	\end{axis}
	\end{tikzpicture}
\end{figure}

\begin{figure}
	\caption{Distributed database with replication - database throughput}
	\label{figure:ddwr_database}
	\centering
	\begin{tikzpicture}
	\begin{axis}[
		title={Throughput against input rate a},
		width=0.9\textwidth,
		ybar=0pt,
		bar width=.02\textwidth,
		xlabel={Rate a},
		ylabel={Throughput},
		xtick=data,
		ymin=0, ymax=5,
		legend pos=north west,
		ymajorgrids=true,
		grid style=dashed,
	]
	
	\addplot [pattern=north east lines, pattern color=blue] table [x index={0}, y index={1}, col sep=comma]{data/ddwr/dbsrv_1.csv};
	\addplot [fill=green] table [x index={0}, y index={1}, col sep=comma]{data/ddwr/dbsrv_2.csv};
	\addplot [pattern=crosshatch, pattern color=brown] table [x index={0}, y index={1}, col sep=comma]{data/ddwr/dbsrv_3.csv};

	\legend{dbsrv1,dbsrv2,dbsrv3}

	\end{axis}
	\end{tikzpicture}
\end{figure}